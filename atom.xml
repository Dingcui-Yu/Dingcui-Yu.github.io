<?xml version="1.0" encoding="utf-8"?>
<feed xmlns="http://www.w3.org/2005/Atom">
  <title>Dingcui Yu&#39;s Homepage</title>
  
  
  <link href="http://dingcuiyu.github.io/atom.xml" rel="self"/>
  
  <link href="http://dingcuiyu.github.io/"/>
  <updated>2023-03-16T07:40:24.942Z</updated>
  <id>http://dingcuiyu.github.io/</id>
  
  <author>
    <name>Dingcui Yu</name>
    
  </author>
  
  <generator uri="https://hexo.io/">Hexo</generator>
  
  <entry>
    <title>ChCore-lab-v2-ECNUver: LAB 2 （持续更新ing）</title>
    <link href="http://dingcuiyu.github.io/2023/03/14/ChCore-lab-v2-ECNUver-LAB-2-%E4%B8%8A%EF%BC%89/"/>
    <id>http://dingcuiyu.github.io/2023/03/14/ChCore-lab-v2-ECNUver-LAB-2-%E4%B8%8A%EF%BC%89/</id>
    <published>2023-03-14T13:39:00.000Z</published>
    <updated>2023-03-16T07:40:24.942Z</updated>
    
    <content type="html"><![CDATA[<h1>实验2：内存管理</h1><p>本实验主要目的在于让同学们熟悉计算机进行地址翻译的过程，并且了解计算机启动过程中，如何对内存初始化，以及启动完成后对内存和页表的管理。</p><p>包括三个部分：内核启动页表、物理内存管理和页表管理。</p><p>注：为了帮助同学们了解这些知识，本节会出现少量“小思考”，不会算入实验报告评分。</p><h2 id="你可能需要了解的背景">你可能需要了解的背景</h2><p>本部分为地址翻译的介绍，若对这一部分有充分了解的同学可以放心跳过~（<strong>但不要跳过思考题</strong>）</p><h3 id="导语：地址翻译的机制">导语：地址翻译的机制</h3><p>内存的访问粒度是Byte（即每次最少读/写一个Byte），每个Byte有一个“编号”，这个“编号”就是地址。<strong>地址空间</strong> 就是可以访问的地址的集合。</p><p>C语言中的指针变量存储的就是数据的地址，我们可以通过<code>%p</code>在<code>printf</code>函数中输出它，例如下面的代码：</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;stdio.h&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="type">int</span> <span class="title function_">main</span><span class="params">(<span class="type">void</span>)</span></span><br><span class="line">&#123;</span><br><span class="line">        <span class="type">int</span> n;</span><br><span class="line">        n=<span class="number">10</span>;</span><br><span class="line">        <span class="type">int</span>* ptr=&amp;n; <span class="comment">//ptr存放n的地址</span></span><br><span class="line">        <span class="built_in">printf</span>(<span class="string">&quot;n=%d\n&quot;</span>,n);</span><br><span class="line">        <span class="built_in">printf</span>(<span class="string">&quot;&amp;n=%p\n&quot;</span>,ptr);</span><br><span class="line">        <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>输出结果（运行于x86-64平台、Linux操作系统）为：</p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">misao@misao-virtual-machine:~$ ./test </span><br><span class="line">n=10</span><br><span class="line">&amp;n=0x7ffed8e6c5bc</span><br></pre></td></tr></table></figure><p>这个地址是 <strong>虚拟地址</strong> ，即应用“看到”，并且使用的地址。数据（如上面的代码中的<code>n</code>）在内存中实际存储的位置是 <strong>物理地址</strong> ，也即访问内存实际用的地址。</p><p>这就引出了两个值得思考的问题：</p><p><strong>问题一：既然需要使用物理地址访问内存，操作系统为什么不直接让应用使用物理地址呢？</strong></p><p>如果操作系统允许应用直接使用物理地址，那么会有两个棘手的问题：第一，难以保证不同应用之间的内存隔离。例如，应用A给变量<code>n</code>赋值10，另一应用B可能故意或者不小心把<code>n</code>改成其他值，进而导致A的运行出错；第二，难以保证一个应用的地址空间连续且统一，当一台机器同时运行多个应用时，它们共享同一块内存，应用难以判断自己可用的空间有多少，此时内存的布局会变得非常复杂。</p><p>这两个难题的原因就是没有一个”领导“协调多个应用对同一个内存的使用，因此，需要操作系统对内存进行统一管理。</p><p>为了实现这一点，需要对物理内存 <strong>虚拟化</strong> ，即令每个应用都认为自己可以使用整块连续的内存，所以说应用使用的地址是虚拟地址，在实际访问时再根据操作系统指定的地址翻译规则进行地址翻译，把虚拟地址翻译为物理地址。</p><p><strong>问题二：虚拟地址到物理地址的转化（翻译）是如何执行的？</strong></p><p>虚拟地址的转化（翻译）是由CPU（硬件）配合操作系统（软件）完成的。一方面，CPU根据地址翻译规则，把虚拟地址转化为物理地址，然后通过总线进行内存读写操作；另一方面，操作系统为每个应用配置地址翻译规则，但不参与具体的翻译过程。</p><p>具体来说，CPU中的重要部件—— <strong>内存管理单元（Memory Management Unit, MMU）</strong> 负责虚拟地址到物理地址的转换。即，应用在CPU上运行时，它使用的虚拟地址由MMU转化为物理地址。当需要访问内存时，MMU翻译得到的物理地址通过总线传到物理内存，从而完成物理内存的读写。</p><blockquote><p>地址翻译体现了”策略与机制分离“的设计思路：操作系统仅仅负责配置地址翻译规则（策略），地址翻译则由CPU完成（机制），二者通过一个特定的数据结构（页表，功能是记录地址翻译规则）实现协同。我们将在下一节介绍页表。</p></blockquote><h4 id="分页机制和页表">分页机制和页表</h4><p>分页机制的基本思想是把应用的虚拟地址空间划分为连续、等长的虚拟页，同时物理地址空间也被划分为连续、等长的物理页。</p><p>假设页大小为4KB，那么虚拟地址0x 0000~0x 1000（即0B~4KB）是虚拟页0，0x 1000~0x 2000（即4KB~8KB）是虚拟页1；类似地，物理地址0x 0000~ 0x1000是物理页0，0x 1000~0x 20000是物理页1。</p><blockquote><p>内存地址一般用十六进制数表示，0x 1000中前面的“0x”表示这是一个十六进制数字，对应的十进制数是4096，即4K。但是计算机读入的数都是二进制数。</p></blockquote><p>虚拟页和物理页大小固定且相等，因此操作系统可以轻松为应用构建一张记录虚拟页到物理页的映射关系表，即页表。</p><p>有了分页机制后，虚拟/物理地址就可以看作由两部分组成：第一部分标识对应的 <strong>页号</strong> ，第二部分标识 <strong>页内偏移</strong> 。假如页大小为4KB，即<span class="katex"><span class="katex-mathml"><math xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><mn>4</mn><mi>K</mi><mo>=</mo><msup><mn>2</mn><mn>12</mn></msup></mrow><annotation encoding="application/x-tex">4K=2^{12}</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:0.6833em;"></span><span class="mord">4</span><span class="mord mathnormal" style="margin-right:0.07153em;">K</span><span class="mspace" style="margin-right:0.2778em;"></span><span class="mrel">=</span><span class="mspace" style="margin-right:0.2778em;"></span></span><span class="base"><span class="strut" style="height:0.8141em;"></span><span class="mord"><span class="mord">2</span><span class="msupsub"><span class="vlist-t"><span class="vlist-r"><span class="vlist" style="height:0.8141em;"><span style="top:-3.063em;margin-right:0.05em;"><span class="pstrut" style="height:2.7em;"></span><span class="sizing reset-size6 size3 mtight"><span class="mord mtight"><span class="mord mtight">12</span></span></span></span></span></span></span></span></span></span></span></span>，则页内偏移需要12位来表示。例如，虚拟地址0x 2008，标识了虚拟页号2和页内偏移0x 8。</p><blockquote><p>这里出现的“用12位来表示”指的是二进制数的前12位，后文中出现的“位数”也指二进制数的位数，例如0x 2008的二进制数为b 0010 0000 0000 1000，这个数字的后12位（0000 0000 1000)表示页内偏移，对应十六进制的后三位。</p></blockquote><p>寻址示意图如下：</p><p><img src="https://s2.loli.net/2023/03/14/VsjC6fUoKkLAgM3.png" alt="寻址示意图"></p><p>MMU拿到应用的虚拟地址（0x 2008）后，查询该应用的页表，得知物理页号是3，得出物理页的基地址为0x 3000，最后加上基地址0x 8得到物理地址0x 3008。</p><blockquote><p>小思考：根据上面的页表，虚拟地址0x1fca对应的物理地址是什么？</p></blockquote><p>这样，对应用来说，自己的地址空间就是连续的：应用只需要使用虚拟地址，不需要关心虚拟地址到物理地址的转换过程。而操作系统可以通过为不同应用建立不同的页表，如对应用A而言，虚拟页号0对应物理页号1，而对应用B而言，虚拟页号0对应物理页号4，从而实现不同应用的内存隔离。</p><p>最后，为了使MMU可以在内存中找到页表，需要把页表的起始地址放在特殊的寄存器中，这个寄存器就是<strong>页表基地址寄存器</strong>，在AArch64平台中，这个寄存器是TTBR（Translation Table Base Register）。</p><blockquote><p>小思考：TTBR中保存的“页表基地址”是物理地址，还是虚拟地址？</p></blockquote><h4 id="多级页表">多级页表</h4><p>上文中出现的页表为单级页表，大家可以计算一下，假如虚拟地址一共有48位，页大小为4K，那么一共有<span class="katex"><span class="katex-mathml"><math xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><mstyle displaystyle="true" scriptlevel="0"><mfrac><msup><mn>2</mn><mn>48</mn></msup><msup><mn>2</mn><mn>12</mn></msup></mfrac></mstyle><mo>=</mo><msup><mn>2</mn><mn>36</mn></msup></mrow><annotation encoding="application/x-tex">\cfrac{2^{48}}{2^{12}}=2^{36}</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:2.276em;vertical-align:-0.686em;"></span><span class="mord"><span class="mopen nulldelimiter"></span><span class="mfrac"><span class="vlist-t vlist-t2"><span class="vlist-r"><span class="vlist" style="height:1.59em;"><span style="top:-2.314em;"><span class="pstrut" style="height:3em;"></span><span class="mord"><span class="mord"><span class="mord">2</span><span class="msupsub"><span class="vlist-t"><span class="vlist-r"><span class="vlist" style="height:0.7401em;"><span style="top:-2.989em;margin-right:0.05em;"><span class="pstrut" style="height:2.7em;"></span><span class="sizing reset-size6 size3 mtight"><span class="mord mtight"><span class="mord mtight">12</span></span></span></span></span></span></span></span></span></span></span><span style="top:-3.23em;"><span class="pstrut" style="height:3em;"></span><span class="frac-line" style="border-bottom-width:0.04em;"></span></span><span style="top:-3.74em;"><span class="pstrut" style="height:3em;"></span><span class="mord"><span class="mord"><span class="mord">2</span><span class="msupsub"><span class="vlist-t"><span class="vlist-r"><span class="vlist" style="height:0.8141em;"><span style="top:-3.063em;margin-right:0.05em;"><span class="pstrut" style="height:2.7em;"></span><span class="sizing reset-size6 size3 mtight"><span class="mord mtight"><span class="mord mtight">48</span></span></span></span></span></span></span></span></span></span></span></span><span class="vlist-s">​</span></span><span class="vlist-r"><span class="vlist" style="height:0.686em;"><span></span></span></span></span></span><span></span></span><span class="mspace" style="margin-right:0.2778em;"></span><span class="mrel">=</span><span class="mspace" style="margin-right:0.2778em;"></span></span><span class="base"><span class="strut" style="height:0.8141em;"></span><span class="mord"><span class="mord">2</span><span class="msupsub"><span class="vlist-t"><span class="vlist-r"><span class="vlist" style="height:0.8141em;"><span style="top:-3.063em;margin-right:0.05em;"><span class="pstrut" style="height:2.7em;"></span><span class="sizing reset-size6 size3 mtight"><span class="mord mtight"><span class="mord mtight">36</span></span></span></span></span></span></span></span></span></span></span></span>个虚拟页。假如每个页表项大小为8 Byte，则页表大小为<span class="katex"><span class="katex-mathml"><math xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><msup><mn>2</mn><mn>36</mn></msup><mo>×</mo><mn>8</mn><mi>B</mi><mo>=</mo><mn>512</mn><mi>G</mi><mi>B</mi></mrow><annotation encoding="application/x-tex">2^{36}\times 8 B= 512 GB</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:0.8974em;vertical-align:-0.0833em;"></span><span class="mord"><span class="mord">2</span><span class="msupsub"><span class="vlist-t"><span class="vlist-r"><span class="vlist" style="height:0.8141em;"><span style="top:-3.063em;margin-right:0.05em;"><span class="pstrut" style="height:2.7em;"></span><span class="sizing reset-size6 size3 mtight"><span class="mord mtight"><span class="mord mtight">36</span></span></span></span></span></span></span></span></span><span class="mspace" style="margin-right:0.2222em;"></span><span class="mbin">×</span><span class="mspace" style="margin-right:0.2222em;"></span></span><span class="base"><span class="strut" style="height:0.6833em;"></span><span class="mord">8</span><span class="mord mathnormal" style="margin-right:0.05017em;">B</span><span class="mspace" style="margin-right:0.2778em;"></span><span class="mrel">=</span><span class="mspace" style="margin-right:0.2778em;"></span></span><span class="base"><span class="strut" style="height:0.6833em;"></span><span class="mord">512</span><span class="mord mathnormal" style="margin-right:0.05017em;">GB</span></span></span></span>！而且，这张页表占据的物理内存必须连续！</p><p>所以，必须想办法压缩页表的大小。</p><p>与此同时，我们发现，<strong>大多数应用使用的虚拟地址远远小于总的虚拟地址空间</strong>，也即单级页表中的大部分表项根本没有被使用。</p><p>因此，在实际场景中，操作系统通常使用<strong>多级页表</strong>，如下图：</p><p><img src="https://s2.loli.net/2023/03/14/scrlBPY9NzWm1FX.png" alt="多级页表"></p><p>64位的虚拟地址实际使用于寻址的有48位，其中12到47位标识虚拟页号，0到11位标识页内偏移。虚拟页号被分为四级，每个级有9位。例如，MMU先读入虚拟地址<code>0x 0000 0000 2008</code>，通过TTBR读入L0页表的物理地址后，再根据39到47位获得L0页表的页表项0，然后读取L0页表中存储的L1物理页号，依次读到L3页表，获得其中存储的物理页号，最后根据页内偏移获得数据的物理地址。</p><blockquote><p>因为页大小为4KB，且每个页表项大小为8 Byte，所以每个页表有<span class="katex"><span class="katex-mathml"><math xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><mstyle displaystyle="true" scriptlevel="0"><mfrac><msup><mn>2</mn><mn>12</mn></msup><msup><mn>2</mn><mn>3</mn></msup></mfrac></mstyle><mo>=</mo><msup><mn>2</mn><mn>9</mn></msup><mo>=</mo><mn>512</mn></mrow><annotation encoding="application/x-tex">\cfrac{2^{12}}{2^3}=2^9=512</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:2.276em;vertical-align:-0.686em;"></span><span class="mord"><span class="mopen nulldelimiter"></span><span class="mfrac"><span class="vlist-t vlist-t2"><span class="vlist-r"><span class="vlist" style="height:1.59em;"><span style="top:-2.314em;"><span class="pstrut" style="height:3em;"></span><span class="mord"><span class="mord"><span class="mord">2</span><span class="msupsub"><span class="vlist-t"><span class="vlist-r"><span class="vlist" style="height:0.7401em;"><span style="top:-2.989em;margin-right:0.05em;"><span class="pstrut" style="height:2.7em;"></span><span class="sizing reset-size6 size3 mtight"><span class="mord mtight">3</span></span></span></span></span></span></span></span></span></span><span style="top:-3.23em;"><span class="pstrut" style="height:3em;"></span><span class="frac-line" style="border-bottom-width:0.04em;"></span></span><span style="top:-3.74em;"><span class="pstrut" style="height:3em;"></span><span class="mord"><span class="mord"><span class="mord">2</span><span class="msupsub"><span class="vlist-t"><span class="vlist-r"><span class="vlist" style="height:0.8141em;"><span style="top:-3.063em;margin-right:0.05em;"><span class="pstrut" style="height:2.7em;"></span><span class="sizing reset-size6 size3 mtight"><span class="mord mtight"><span class="mord mtight">12</span></span></span></span></span></span></span></span></span></span></span></span><span class="vlist-s">​</span></span><span class="vlist-r"><span class="vlist" style="height:0.686em;"><span></span></span></span></span></span><span></span></span><span class="mspace" style="margin-right:0.2778em;"></span><span class="mrel">=</span><span class="mspace" style="margin-right:0.2778em;"></span></span><span class="base"><span class="strut" style="height:0.8141em;"></span><span class="mord"><span class="mord">2</span><span class="msupsub"><span class="vlist-t"><span class="vlist-r"><span class="vlist" style="height:0.8141em;"><span style="top:-3.063em;margin-right:0.05em;"><span class="pstrut" style="height:2.7em;"></span><span class="sizing reset-size6 size3 mtight"><span class="mord mtight">9</span></span></span></span></span></span></span></span><span class="mspace" style="margin-right:0.2778em;"></span><span class="mrel">=</span><span class="mspace" style="margin-right:0.2778em;"></span></span><span class="base"><span class="strut" style="height:0.6444em;"></span><span class="mord">512</span></span></span></span>项，为了索引512个页表项，需要9位，所以虚拟页号的每一级有9位。</p></blockquote><p>多级页表的好处就是，当任意一级页表中的某一个条目位空时，该条目对应的下一级页表不需要存在。换句话说，多级页表允许整个页表结构出现“空洞”，而单级页表则需要每一项都实际存在。</p><p>而在实际情况下，应用的虚拟地址空间中绝大多数虚拟地址不会被使用，所以多级页表通常具有许多“空洞”，从而能极大节约页表占用的空间。</p><h4 id="思考题-1">思考题 1</h4><blockquote><p>1995年，Intel在奔腾Pro处理器上推出PAE（Physical Address Extension）技术，支持36位物理地址（即最大64GB），但虚拟地址依然只有32位（即虚拟地址空间为32GB）。由于物理地址是36位，所以页表项大小为 64位（8 Byte），每个页表依然有512项，使用9位索引，因此使用2+9+9+12三级索引。请计算在用满4GB的虚拟地址空间的情况下，多级页表和单级页表分别占用多少空间？并且思考多级页表一定能减少单级页表占用的空间吗？</p></blockquote><h3 id="AArch64地址翻译">AArch64地址翻译</h3><p>MMU硬件在EL1特权级（操作系统运行的特权级）中提供了两个页表基地址寄存器，分别是<code>TTBR0_EL1</code>和<code>TTBR1_EL1</code>。当虚拟地址的48~63位全为0时，MMU硬件基于<code>TTBR0_EL1</code>寄存器存储的页表进行地址翻译；当虚拟地址的48~63位全为1时，MMU硬件基于<code>TTBR1_EL1</code>寄存器存储的页表进行地址翻译。</p><p>即0x 0000 0000 0000 ~ 0x 0000 ffff ffff的地址使用<code>TTBR0_EL1</code>寄存器，0x ffff 0000 0000~0x ffff ffff ffff 的地址使用<code>TTBR1_EL1</code>寄存器。</p><h4 id="页表项">页表项</h4><p>页表项（Page Table Entry，简称PTE）一般存储表描述符或页描述符，除了下一级页表（或者物理页）的物理页号（Page Frame Number，简称PFN）外，还存储一些属性位。如下图，第0位为<code>is_valid</code>位，为1时表示这个页表项有效，第1位为<code>is_page</code>或者<code>is_table</code>位，为1时表示页表项中的PFN指向的是页表或者物理页。</p><p><img src="https://s2.loli.net/2023/03/14/Sdo8Pf794gKluWY.png" alt="页表项"></p><h4 id="思考题-2">思考题 2</h4><blockquote><p>上图中还出现了其他属性位，如UXN、PXN、AF、AP，请你阅读ChCore中<code>kernel\include\arch\aarch64\arch\mm\page_table.h</code>中对<code>pte_t</code>的定义，并结合查阅到的其他资料，说明这四个属性位的作用。</p></blockquote><h4 id="大页">大页</h4><p>如下图，多级页表中并非只有最后一级页表项能指向物理页，中间级的页表项也能直接指向物理页而非下一级页表。</p><p><img src="https://s2.loli.net/2023/03/14/2SZ9izKT5r7uhnO.png" alt="大页"></p><p>这些中间级页表项指向的页就是<strong>大页</strong>，对应的页表项为块描述符。</p><p>块描述符如下图所示，注意与表描述符的区别：</p><p><img src="https://s2.loli.net/2023/03/14/uFCyIJ2UBmR8r5G.png" alt="块描述符"></p><h4 id="思考题-3">思考题 3</h4><blockquote><p>请思考多级页表相比单级页表带来的优势和劣势（如果有的话），并计算在 AArch64 页表中分别以 4KB 粒度和 2MB 粒度映射 0～4GB 地址范围所需的物理内存大小（或页表页数量）。</p></blockquote><h2 id="第一部分：配置内核启动页表">第一部分：配置内核启动页表</h2>]]></content>
    
    
      
      
    <summary type="html">&lt;h1&gt;实验2：内存管理&lt;/h1&gt;
&lt;p&gt;本实验主要目的在于让同学们熟悉计算机进行地址翻译的过程，并且了解计算机启动过程中，如何对内存初始化，以及启动完成后对内存和页表的管理。&lt;/p&gt;
&lt;p&gt;包括三个部分：内核启动页表、物理内存管理和页表管理。&lt;/p&gt;
&lt;p&gt;注：为了帮助同学们了</summary>
      
    
    
    
    <category term="OSLab" scheme="http://dingcuiyu.github.io/categories/OSLab/"/>
    
    
    <category term="实验手册" scheme="http://dingcuiyu.github.io/tags/%E5%AE%9E%E9%AA%8C%E6%89%8B%E5%86%8C/"/>
    
  </entry>
  
  <entry>
    <title>test</title>
    <link href="http://dingcuiyu.github.io/2023/03/14/test/"/>
    <id>http://dingcuiyu.github.io/2023/03/14/test/</id>
    <published>2023-03-14T09:06:45.000Z</published>
    <updated>2023-03-14T14:21:01.379Z</updated>
    
    <content type="html"><![CDATA[<h1>test</h1><p>This is a test file.</p>]]></content>
    
    
      
      
    <summary type="html">&lt;h1&gt;test&lt;/h1&gt;
&lt;p&gt;This is a test file.&lt;/p&gt;
</summary>
      
    
    
    
    
  </entry>
  
</feed>
